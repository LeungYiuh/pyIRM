#! /usr/local/bin/python3
# -*- coding:utf-8 -*-
'''
this is for IRM decompose, based on log gaussian,

this is based on python3

author: Jiabo Liu
GFZ Potsdam
'''

import sys
import os
import pandas as pd
import codecs
import matplotlib
matplotlib.use('Qt5Agg')
from PyQt5 import QtCore
from PyQt5.QtWidgets import (QApplication,QMainWindow,QGridLayout,QSizePolicy,
                             QWidget,QAction,QFileDialog,QPushButton,QTextEdit,
                             QLabel,QLineEdit,QVBoxLayout)
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from lea import Lea
from matplotlib import pyplot as plt
from scipy import interpolate
import numpy as np
from sklearn.mixture import GaussianMixture as GMM
from lmfit.models import GaussianModel
from lmfit import minimize,Parameters


class MyMplCanvas(FigureCanvas):
    def __init__(self,parent=None,width=5,hight=4,dpi=100,filePath=None,groups=None,paramDict=None):
        self.filePath=filePath
        self.groups=groups
        self.paramDict=paramDict
        plt.ioff()
        self.fig = plt.figure(figsize=(width,hight),dpi=dpi,facecolor='white')
        self.fig.subplots_adjust(left=0.18, right=0.97,
                        bottom=0.18, top=0.9, wspace=0.5, hspace=0.5)
        self.axes = self.fig.add_subplot(111)
        #self.axes.hold(False)
        self.initialplot()
        FigureCanvas.__init__(self,self.fig)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(self,
                                   QSizePolicy.Expanding,
                                   QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

    def initialplot(self):
        pass

class dataFit():
    '''
    this is the main part for data fitting

    '''
    def __init__(self,filePath,fitNumber):
        self.filePath=filePath
        self.fitNumber=fitNumber
        self.raw_data()
        self.rand_data()
        self.loggausfit()
        self.lmfit_result()

        #return self.params,self.x_fit,self.y_gradient,self.y_fit,self.x_measure,self.y_measure

    def raw_data(self):
        '''
        loading raw data file, which is the raw data file that
        generated by MircoMag, only if there are more than two
        rows of floats, the program would regard it as correct
        data file.
        Be aware that x_fit using log10 scale for easy fitting,
        and will changed to linear scale for plotting.
        '''
        '''
        with codecs.open(self.filePath,encoding='utf-8',errors='ignore') as f:
            data = [[float(line.split(',')[0].strip()),float(line.split(',')[1])]
                    for line in f.readlines()
                    if len(line.split(','))==2 and float(line.split(',')[0])]
        data=sorted(data)
        self.y_measure = [float(i[1]) for i in data if float(i[0])>=0.001]
        self.x_measure = [float(i[0])*10**3 for i in data if float(i[0])>=0.001]
        '''
        rawdata=pd.read_csv(self.filePath,sep='\s+',delimiter=',',header=0,dtype=np.float64)
        y_measure=rawdata.remanance
        x_measure=rawdata.field*10**3
        self.x_measure=[i for i in x_measure if i >=2]
        self.y_measure=[y_measure[i] for i in range(len(x_measure)) if x_measure[i]>=2]
        self.x_fit = np.linspace(np.log10(self.x_measure).min(), np.log10(self.x_measure).max(), 100)
        y_gradient_init = interpolate.splev(self.x_fit, interpolate.splrep(np.log10(self.x_measure), np.gradient(self.y_measure)))
        y_gradient=[]
        for i in y_gradient_init:
            if i >0:
                y_gradient.append(i)
            else:
                #print(i)
                y_gradient.append(10**-15)
        self.y_gradient = np.array(y_gradient)
    def rand_data(self):
        '''
        the IRM gradient curve can be regarded as frequency distribution,
        as a result, generating one dimensional random data set for log
        gaussian fitting
        '''
        tup_data={}
        for i in range(len(self.x_fit)):
            tup_data[str(self.x_fit[i])]=self.y_gradient[i]/sum(self.y_gradient)*100
        #print(tup_data)
        rand = Lea.fromValFreqsDict(tup_data)
        self.data_1D =np.array([[i] for i in rand.random(100)],dtype=np.float)
    def loggausfit(self):
        '''
        import sklearn GMM model, to evaluate the initial value for fitting,
        and then import lmfit to iterate and get the parameters of the best
        fit.
        '''
        N = np.arange(self.fitNumber, self.fitNumber+1)
        models = [None for i in range(len(N))]
        for i in range(len(N)):
            models[i] = GMM(N[i]).fit(self.data_1D)
        # compute the AIC and the BIC
        AIC = [m.aic(self.data_1D) for m in models]
        M_best = models[np.argmin(AIC)]
        logprob = M_best.score_samples(self.x_fit.reshape((-1,1)))#M_best.eval(x)
        responsibilities = M_best.predict_proba(self.x_fit.reshape((-1,1)))
        pdf = np.exp(logprob)
        self.pdf_individual = responsibilities * pdf[:, np.newaxis]
        self.y_fit = (pdf.max())*(self.y_gradient/(self.y_gradient.max()))
    def lmfit_result(self):
        for i in np.arange(self.fitNumber):
            sequence = 'g'+str(i+1)+'_'
            if i==0:
                gauss = GaussianModel(prefix=sequence)
                pars = gauss.guess(self.pdf_individual[:,i], x = self.x_fit)
                center_value = pars[sequence+'center'].value
                pars[sequence+'center'].set(center_value, min=center_value-0.2, max=center_value+0.2)
                sigma_value = pars[sequence+'sigma'].value
                pars[sequence+'sigma'].set(sigma_value, min=sigma_value-0.2, max=sigma_value+0.2)
            else:
                gauss = GaussianModel(prefix=sequence)
                pars.update(gauss.guess(self.pdf_individual[:,i], x = self.x_fit))
                center_value = pars[sequence+'center'].value
                pars[sequence+'center'].set(center_value, min=center_value, max=center_value+0.2)
                sigma_value = pars[sequence+'sigma'].value
                pars[sequence+'sigma'].set(sigma_value, min=sigma_value-0.2, max=sigma_value+0.2)
        params = pars
        result = minimize(self.residuals, params, args=(self.x_fit, self.y_fit), method='cg')
        self.params = result.params
    def residuals(self,params, x, y):
        y_component = self.func(x, params)
        return y - sum(y_component)
    def func(self,x,params):
        y_component=[]
        for i in np.arange(self.fitNumber):
            A = 'g'+str(i+1)+'_amplitude'
            s = 'g'+str(i+1)+'_sigma'
            c = 'g'+str(i+1)+'_center'
            A = params[A].value
            s= params[s].value
            c= params[c].value
            y = A/(s*np.sqrt(2*np.pi))*np.exp(-(x-c)**2/(2*s**2))
            y_component.append(y)
        return y_component
class reFit(MyMplCanvas):
    def initialplot(self):
        self.fitNumber=int(self.groups)
        dataFit.raw_data(self)
        dataFit.rand_data(self)
        dataFit.loggausfit(self)
        self.replot()
    def replot(self):
        params = Parameters()
        for key,value in self.paramDict.items():
            params.add(key, value=float(value.text()))
        for i in np.arange(self.fitNumber):
            sequence = 'g'+str(i+1)+'_'
            center_value = params[sequence+'center'].value
            params[sequence+'center'].set(center_value, min=center_value-0.05, max=center_value+0.05)
            sigma_value = params[sequence+'sigma'].value
            params[sequence+'sigma'].set(sigma_value, min=sigma_value-0.05, max=sigma_value+0.05)
            ampl_value = params[sequence+'amplitude'].value
            params[sequence+'amplitude'].set(ampl_value, min=ampl_value-0.5,max=ampl_value+0.5)
        result = minimize(self.residuals, params, args=(self.x_fit, self.y_fit), method='cg')
        self.params = result.params
        FitMplCanvas.fitPlot(self)
    def func(self,x,params):
        return dataFit.func(self,x,params)
    def residuals(self,params,x,y):
        return dataFit.residuals(self,params,x,y)

class FitMplCanvas(MyMplCanvas):
    '''
    this is the ploting part, all the data generated by fitting are assembled here,
    be carefull, the ploting scale of the X axies need to changed to linear scale,
    that is why x_draw = 10**x_fit.

    as well as the Y scale, the fit value and measured gradient value should be
    consistent, as a result, the coefficient p=y_gradient.max()/fit_curve.max()
    is adopted.

    the data for plotting is also for output.
    '''
    def initialplot(self):
        if self.groups==None:
            group=3
        else:
            group=self.groups
        self.fitNumber=int(group)
        dataFit.raw_data(self)
        self.params=dataFit(self.filePath,self.fitNumber).params
        self.fitPlot()

    def fitPlot(self):
        ax=self.axes
        x_measure=self.x_measure
        y_measure=self.y_measure
        x_fit=self.x_fit
        params=self.params
        y_gradient=self.y_gradient
        group_number=self.fitNumber
        #ax.plot(10**x_fit,y_gradient,color='pink')
        ax.scatter(x_measure, np.gradient(y_measure), facecolors='white', edgecolors='k', s=15, marker='o', alpha=1,
           label='Measured')
        #ax.plot(10**x_fit, y_gradient)

        y_components = self.func(x_fit, params)
        fit_curve = sum(y_components)
        #print(y_gradient.max()/fit_curve.max(),y_gradient.max(),fit_curve.max())
        p =y_gradient.max()/fit_curve.max()            #转换系数
        x_draw = 10**x_fit
        color = ['#e41a1c','#4daf4a','#377eb8','#984ea3','#ff7f00']
        ax.plot(x_draw, fit_curve*p, '-k', label='Fit')
        #ax.plot(x_draw,y_fit*p)
        label_size = 18
        ax.set_xlabel('Filed (mT)', fontsize=label_size)
        ax.set_ylabel('IRM acquisition gradient', fontsize=label_size)
        ax.set_xscale('log')
        ax.set_xlim(2, 3000)
        ax.set_ylim(0, y_gradient.max()*1.1)
        ax.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
        plt.tick_params(axis='both', which='major', labelsize=label_size)

        y_sum = []
        for i in np.arange(group_number):
            y_sum.append(sum(y_components[i]))

        y_sort =sorted(y_sum, reverse=True)
        for m in np.arange(len(y_sort)):
            for n in np.arange(group_number):
                sequence = 'g'+str(n+1)+'_'
                if y_sort[m] == sum(y_components[n]):
                    x_mean = [x_draw[i] for i in np.arange(len(y_components[n])) if y_components[n][i] == np.max(y_components[n])]
                    content=sum(y_components[n])/sum(y_sum)*100
                    label = str(np.int(content))+'%   '+ str(np.int(x_mean[0]))+' mT\n' +\
                            'dp='+str('%.2f'%params[sequence+'sigma'].value)
                    ax.plot(x_draw, y_components[n]*p, color=color[m],label=label)
                    plt.legend(frameon=False, fontsize = 13)
        self.outputXdata = x_draw
        self.outputYdata = [line*p for line in y_components]
    def func(self,x,params):
        return dataFit.func(self,x,params)
class adjustFit(MyMplCanvas):
    def initialplot(self):
        self.fitNumber=int(self.groups)
        dataFit.raw_data(self)
        self.replot()
    def replot(self):
        params = Parameters()
        for key,value in self.paramDict.items():
            params.add(key, value=float(value.text()))
        self.params=params
        FitMplCanvas.fitPlot(self)
    def func(self,x,params):
        return dataFit.func(self,x,params)

class MyplotMplCanvas(MyMplCanvas):
    def initialplot(self):
        if self.filePath==None:
            self.data_init()
        else:
            self.data_raw()
        #self.axes.plot(self.x_measure,self.y_measure)
        #self.axes.set_xscale('log')
    def error(self):
        return self.err

    def data_raw(self):
        '''
        with codecs.open(self.filePath,encoding='utf-8',errors='ignore') as f:
            try:
                data = [[line.split(',')[0],line.split(',')[1]]
                        for line in f.readlines()
                        if len(line.split(','))==2 and float(line.split(',')[0])]
            except:
                print('data format is not correct')
                pass
        self.y_measure = [float(i[1].strip()) for i in data if float(i[0])>=0.001]
        self.x_measure = [float(i[0])*10**3 for i in data if float(i[0])>=0.001]
        '''
        try:
            rawdata=pd.read_csv(self.filePath,sep='\s+',delimiter=',',header=0,dtype=np.float64)
            self.y_measure=rawdata.remanance
            self.x_measure=rawdata.field*10**3
            self.axes.plot(self.x_measure,self.y_measure)
            self.axes.set_xscale('log')
        except Exception as e:
            self.err='Warning: two columns of filed, irm data format required'
            pass
    def data_init(self):
        self.axes.plot(0,0)
        self.axes.set_xlim(0,1)
        self.axes.set_ylim(0,1)


class Mainwindow(QMainWindow):
    '''
    this is for the interface
    '''
    def __init__(self):
        super().__init__()

        self.clickCount=0

        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)

        self.main_widget = QWidget(self)
        self.grid = QGridLayout(self.main_widget)
        self.vbox = QVBoxLayout()

        btLoad = QPushButton('Load',self.main_widget)
        btRaw = QPushButton('Raw data', self.main_widget)
        #btAdjust = QPushButton(Adjust)
        numberLabel = QLabel('Numbers',self.main_widget)
        self.introdueLabel = QLabel('Introdcution',self.main_widget)
        self.numberText =QLineEdit('3')
        btFit = QPushButton('Fit',self.main_widget)
        btSaveFig = QPushButton('Save Fig', self.main_widget)
        btSaveData = QPushButton('Save Data', self.main_widget)
        btRefit = QPushButton('reFit', self.main_widget)

        self.dataDisp = QTextEdit(self.main_widget)

        btLoad.clicked.connect(self.loadButton)
        btRaw.clicked.connect(self.rawButton)
        btFit.clicked.connect(self.fitButton)
        btSaveFig.clicked.connect(self.SaveFigButton)
        btSaveData.clicked.connect(self.SaveDataButton)
        btRefit.clicked.connect(self.reFit)

        #self.plotButtom()
        #grid.addWidget(self.plot,1,2,2,1)
        self.plot = MyplotMplCanvas(self.main_widget,width=5,hight=4,dpi=100,filePath=None)
        self.grid.addWidget(self.plot,1,3,5,2)
        self.grid.addWidget(self.dataDisp,1,1,8,1)
        self.grid.addWidget(self.introdueLabel,6,3,3,2)

        self.vbox.addWidget(btLoad,1)
        self.vbox.addWidget(btRaw,2)
        self.vbox.addWidget(numberLabel,3)
        self.vbox.addWidget(self.numberText,4)
        self.vbox.addWidget(btFit,5)
        self.vbox.addWidget(btSaveFig,6)
        self.vbox.addWidget(btSaveData,7)
        self.vbox.addWidget(btRefit,8)

        self.grid.addLayout(self.vbox,1,2,2,1)


        self.main_widget.setFocus()
        self.setCentralWidget(self.main_widget)

        self.initUI()

        self.show()

    def initUI(self):
        self.statusBar()

        openfile = QAction('open',self)
        openfile.triggered.connect(self.showDialog)
        quitAction = QAction('quit',self)
        quitAction.triggered.connect(self.fileQuit)

        menubar = self.menuBar()
        menubar.setNativeMenuBar(False)
        filename = menubar.addMenu('&File')
        filename.addAction(openfile)
        filename.addAction(quitAction)

        quitname = menubar.addMenu('&Help')
        menubar.addSeparator()
        quitname.addAction(quitAction)

        self.setGeometry(300,300,800,700)
        self.setWindowTitle('pyIRM')

    def showParams(self):
        subGrid = QGridLayout()
        params = self.plot.params
        self.paramDict = {}
        for i in range(int(self.groups)):
            A = 'g'+str(i+1)+'_amplitude'
            s = 'g'+str(i+1)+'_sigma'
            c = 'g'+str(i+1)+'_center'
            AA = '%.5f'%params[A].value
            ss= '%.5f'%params[s].value
            cc= '%.5f'%params[c].value
            sigmaLable = QLabel('sigma-'+str(i+1))
            sigmaValue = QLineEdit(str(ss))
            centerLable = QLabel('center-'+str(i+1))
            centerValue = QLineEdit(str(cc))
            amplitudeLable = QLabel('Amplitude'+str(i+1))
            amplitudeValue = QLineEdit(str(AA))
            self.paramDict[A] = amplitudeValue
            self.paramDict[s] = sigmaValue
            self.paramDict[c] = centerValue
            subGrid.addWidget(sigmaLable,i,0,1,1)
            subGrid.addWidget(sigmaValue,i,1,1,1)
            subGrid.addWidget(centerLable,i,2,1,1)
            subGrid.addWidget(centerValue,i,3,1,1)
            subGrid.addWidget(amplitudeLable,i,4,1,1)
            subGrid.addWidget(amplitudeValue,i,5,1,1)
        for key, value in self.paramDict.items():
            value.textChanged.connect(self.adjustPlot)
        return subGrid
    def adjustPlot(self):
        if self.plot:
            plt.close(self.plot.fig)
        self.plot = adjustFit(self.main_widget,width=5,hight=4,dpi=100,filePath=self.filePath,
                              groups=self.groups,paramDict=self.paramDict)
        try:
            self.grid.addWidget(self.plot,1,3,5,2)
        except Exception as e:
            pass
    def reFit(self):

        self.removeGrid()
        if self.plot:
                plt.close(self.plot.fig)

        if self.paramDict:
            self.plot = reFit(self.main_widget,width=5,hight=4,dpi=100,filePath=self.filePath,
                          groups=self.groups,paramDict=self.paramDict)
        self.grid.addWidget(self.plot,1,3,5,2)
        self.paramsGrid=self.showParams()
        self.grid.addLayout(self.paramsGrid,6,3,3,2)
    def showDialog(self):
        filename=QFileDialog.getOpenFileName(self,'open file','/home/Documents/')
        if filename[0]:
            f = codecs.open(filename[0],'r',encoding='utf-8',errors='ignore')
            with f:
                data=f.read()
                self.dataDisp.setText(data)
                self.filePath=filename[0]
                self.workPath=os.path.dirname(filename[0])
            f.close()

    def fileQuit(self):
        sys.exit(app.exec_())

    def loadButton(self):
        self.statusBar().showMessage(self.sender().text())
        self.showDialog()
    def rawButton(self):
        if self.plot:
            plt.close(self.plot.fig)
        try:
            if self.paramDict:
                import gc
                del self.paramDict
                gc.collect()
        except Exception as e:
            pass
        #self.statusBar().showMessage(self.sender().text())
        self.plot = MyplotMplCanvas(self.main_widget,width=5,hight=4,dpi=100,filePath=self.filePath)
        if self.plot.error():
            self.statusBar().showMessage(self.plot.error())
        self.grid.addWidget(self.plot,1,3,5,2)
    def SaveFigButton(self):
        if self.plot:
            self.plot.fig.savefig(os.path.splitext(self.filePath)[0]+'.png')
        else:
            pass
    def SaveDataButton(self):
        if self.plot:
            '''
            dataFile = os.path.splitext(self.filePath)[0]+'_fit.dat'
            data = open(dataFile, 'w')
            #self.params,self.x_fit,self.y_gradient,self.y_fit,self.x_measure,self.y_measure=
            data.write('measured field'+'\n')
            data.write(str(self.plot.x_measure).strip('[]')+'\n')
            data.write('measured IRM'+'\n')
            data.write(str(self.plot.y_measure).strip('[]')+'\n')
            data.write('fitted field'+'\n')
            data.write(str(list(self.plot.outputXdata)).strip('[]')+'\n')
            data.write('fitted IRM'+'\n')
            data.write(str(list(sum(self.plot.outputYdata))).strip('[]')+'\n')
            for i in np.arange(len(self.plot.outputYdata)):
                data.write('fitted IRM component '+str(i+1)+'\n')
                data.write(str(list(self.plot.outputYdata[i])).strip('[]')+'\n')
            '''
            #----------------------------------------------------------------------
            #using pandas save csv file
            mField = self.plot.x_measure
            mIrm = self.plot.y_measure
            #print(self.plot.outputXdata.tolist())
            fField = self.plot.outputXdata.tolist()
            fIrm  = sum(self.plot.outputYdata).tolist()
            data_dict = {'measured field':mField, 'measured IRM':mIrm,
                               'fitted field':fField, 'fitted IRM':fIrm}
            df = pd.DataFrame.from_dict(data_dict, orient='index')
            df = df.transpose()
            for i in np.arange(len(self.plot.outputYdata)):
                fIrmcomp = self.plot.outputYdata[i].tolist()
                df['fitted IRM comoponent '+str(i+1)] = fIrmcomp
            fileName = os.path.splitext(self.filePath)[0]+'_fit.csv'
            df.to_csv(fileName)
        else:
            pass
    def fitButton(self):
        if self.clickCount !=0:
            self.removeGrid()
        else:
            self.introdueLabel.deleteLater()
        if self.plot:
            plt.close(self.plot.fig)
        self.statusBar().showMessage(self.sender().text())
        self.groups = self.numberText.text()
        self.plot = FitMplCanvas(self.main_widget,width=5,hight=4,dpi=100,filePath=self.filePath,groups=self.groups)
        self.grid.addWidget(self.plot,1,3,5,2)
        self.paramsGrid=self.showParams()
        self.grid.addLayout(self.paramsGrid,6,3,3,2)
        self.clickCount +=1
    def removeGrid(self):
        for i in range(int(self.groups)*6):
            self.paramsGrid.takeAt(int(self.paramsGrid.count())-1).widget().close()
        self.grid.removeItem(self.paramsGrid)
    def Adjust(self):
        print('ss')

if __name__=='__main__':
     app = QApplication(sys.argv)
    Mwindow = Mainwindow()
    sys.exit(app.exec_())
